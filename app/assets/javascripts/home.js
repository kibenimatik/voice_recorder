document.addEventListener('DOMContentLoaded', function(event) {
  var AudioContext, URL, audioContext, createUploadButton, gumStream, input, rec, recordButton, startRecording, stopButton, stopRecording;
  URL = window.URL || window.webkitURL;
  gumStream = void 0;
  rec = void 0;
  input = void 0;

  /*
    MediaStreamAudioSourceNode we'll be recording
    shim for AudioContext when it's not avb.
   */
  AudioContext = window.AudioContext || window.webkitAudioContext;
  audioContext = void 0;
  startRecording = function() {
    var constraints;
    console.log('recordButton clicked');
    constraints = {
      audio: true,
      video: false
    };

    /*
      Disable the record button until we get a success or fail from getUserMedia()
     */
    recordButton.disabled = true;
    stopButton.disabled = false;
    navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
      console.log('getUserMedia() success, stream created, initializing Recorder.js ...');
      audioContext = new AudioContext;

      /*
        Assign to gumStream for later use in stopButton()
       */
      gumStream = stream;
      input = audioContext.createMediaStreamSource(stream);

      /*
        Create the Recorder object and configure to record mono sound (1 channel)
        Recording 2 channels  will double the file size
       */
      rec = new Recorder(input, {
        numChannels: 1,
        workerPath: '/recorderWorker.js'
      });

      /*
        Start the recording process
       */
      rec.record();
      console.log('Recording started');
    })["catch"](function(err) {
      recordButton.disabled = false;
      stopButton.disabled = true;
    });
  };
  stopRecording = function() {
    console.log('stopButton clicked');

    /*
      Disable the stop button, enable the record too allow for new recordings
     */
    stopButton.disabled = true;
    recordButton.disabled = false;

    /*
      Tell the recorder to stop the recording
     */
    rec.stop();

    /*
      Stop microphone access
     */
    gumStream.getAudioTracks()[0].stop();

    /*
      Create the wav blob and pass it on to createUploadButton
     */
    rec.exportWAV(createUploadButton);
  };
  createUploadButton = function(blob) {
    var audioTag, filename, uploadButton, url, wrapper;
    url = URL.createObjectURL(blob);
    wrapper = document.createElement('div');
    wrapper.className = "well";
    audioTag = document.createElement('audio');
    audioTag.controls = true;
    audioTag.src = url;
    wrapper.appendChild(audioTag);

    /*
      Name of .wav file needs for Shrine for correct path calculation
     */
    filename = (new Date).toISOString() + '.wav';
    uploadButton = document.createElement('a');
    uploadButton.className = "btn btn-primary";
    uploadButton.href = '#';
    uploadButton.innerHTML = 'Upload';
    uploadButton.addEventListener('click', function(event) {
      var fd, xhr;
      xhr = new XMLHttpRequest;
      xhr.onload = function(e) {
        if (this.readyState === 4) {
          alert('Uploaded!');
        }
      };
      fd = new FormData;
      fd.append('audio', blob, filename);
      xhr.open('POST', '/upload', true);
      xhr.send(fd);
    });

    /*
      wrapper.appendChild document.createTextNode(' ')
     */
    wrapper.appendChild(uploadButton);
    recordingsList.appendChild(wrapper);
  };

  /*
    Define buttons
   */
  recordButton = document.getElementById('recordButton');
  stopButton = document.getElementById('stopButton');

  /*
    Add events to those 2 buttons
   */
  if (typeof recordButton !== 'undefined' && recordButton !== null) {
    recordButton.addEventListener('click', startRecording);
  }
  if (typeof stopButton !== 'undefined' && stopButton !== null) {
    return stopButton.addEventListener('click', stopRecording);
  }
});

// ---
// generated by coffee-script 1.9.2
